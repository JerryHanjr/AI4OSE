# Ch2 学习指南：批处理系统

## 学习目标

理解内核如何加载和运行用户程序，以及用户态和内核态之间的切换机制。

## 核心问题清单

### 基础问题
1. 批处理系统和现代操作系统有什么区别？
2. 用户程序的二进制数据是如何嵌入到内核镜像中的？（提示：看 build.rs 和 `APP_ASM`）
3. `LocalContext::user(app_base)` 做了什么？为什么需要设置 sstatus.SPP = User？

### Trap 机制
4. 用户程序执行 `ecall` 指令后，CPU 硬件自动做了哪些事？
5. scause 寄存器存储了什么信息？如何区分异常和中断？
6. 为什么系统调用返回时需要 `sepc += 4`？如果不加会怎样？

### 安全隔离
7. app1（store_fault）为什么能被内核捕获并杀死？硬件做了什么？
8. app3 尝试执行特权指令为什么会触发 IllegalInstruction？
9. 内核杀死异常应用后，为什么需要 `fence.i`？

## AI 对话示例

```
你：ecall 指令执行后 CPU 做了什么？

AI：ecall 触发一个环境调用异常，CPU 硬件自动完成以下操作：
1. 将 pc 保存到 sepc
2. 将当前特权级和中断使能保存到 sstatus
3. 将异常原因写入 scause
4. 将 pc 设置为 stvec（Trap 处理入口）
5. 切换到 S 态

你：那 sret 又做了什么？

AI：sret 是 Trap 返回指令，它反向操作：
1. 从 sstatus.SPP 恢复特权级
2. 将 pc 设置为 sepc 的值
3. 恢复中断使能
```

## 实验步骤

1. 阅读 `ch2/src/main.rs`（248行）
2. 重点关注 `rust_main` 中的批处理循环和 `handle_syscall`
3. 编译运行，观察 8 个用户程序的执行结果
4. 对比 app0（正常）和 app1（异常）的行为差异

## 扩展思考

- 所有 app 加载到同一地址 0x80400000，如果两个 app 同时在内存中会怎样？
- 如果用户程序执行了一个死循环，内核能怎么办？（提示：Ch3 解决了这个问题）
- 用户栈和内核栈为什么要分开？
