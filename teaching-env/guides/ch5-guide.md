# Ch5 学习指南：进程管理

## 学习目标

理解进程的完整生命周期：创建、执行、等待、退出。

## 核心问题清单

### 进程基础
1. "进程"和"程序"有什么区别？
2. PCB（进程控制块）需要包含哪些信息？和 Ch3 的 TCB 有什么区别？
3. initproc 是什么？为什么需要一个初始进程？
4. 进程树是什么结构？父子关系有什么作用？

### fork/exec 模型
5. fork 系统调用做了什么？父进程和子进程返回值为什么不同？
6. exec 系统调用做了什么？为什么要替换整个地址空间？
7. 为什么 Unix 选择 fork+exec 而不是直接 spawn？（提示：灵活性）
8. fork 后子进程的寄存器状态和父进程完全一样吗？

### 进程生命周期
9. wait/waitpid 系统调用的作用是什么？如果父进程不 wait 会怎样？
10. 进程退出后资源如何回收？exit_code 如何传递给父进程？

## AI 对话示例

```
你：fork 的返回值为什么在父子进程中不同？

AI：fork 创建了一个子进程，它是父进程的副本。在内核实现中：
- 子进程的 a0 寄存器被设为 0（fork 返回 0）
- 父进程的 a0 寄存器被设为子进程的 PID

关键代码：
    *context.a_mut(0) = 0;          // 子进程返回 0
    pid.get_usize() as isize        // 父进程返回子 PID

这样用户程序可以通过返回值区分自己是父还是子：
    let pid = fork();
    if pid == 0 { /* 我是子进程 */ }
    else { /* 我是父进程，子进程PID=pid */ }

你：为什么这个设计很巧妙？

AI：这让父进程知道子进程的 PID（用于 wait），而子进程知道自己是新创建的
（通常会立即 exec 加载新程序）。一次系统调用，两种角色，零额外通信。
```

## Shell 的工作流程

理解 Shell 是理解 Ch5 的关键：

```
Shell 启动
  ↓
显示 ">> " 提示符
  ↓
读取用户输入（程序名）
  ↓
fork() → 父进程              子进程
           ↓                    ↓
         waitpid()          exec(程序名)
           ↓                    ↓
         等待子进程...      运行目标程序
           ↓                    ↓
         获取退出码          exit(code)
           ↓
         回到 ">> " 提示符
```

## 实验步骤

1. 阅读 `ch5/src/main.rs`（784行）
2. 重点关注 fork/exec/wait 的实现
3. 运行实验，观察 Shell 启动
4. 理解从 rust_main → initproc → user_shell 的启动链

## 扩展思考

- spawn 系统调用为什么标记为 `todo!()`？它和 fork+exec 相比有什么优势？
- 如果一个进程 fork 了 100 次，内存会不会爆？（提示：Copy-on-Write）
- Ch5 的 MEMORY 从 24 MiB 增加到 48 MiB，为什么？
- set_priority 练习题是关于什么的？（提示：Stride 调度算法）
