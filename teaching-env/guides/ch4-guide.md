# Ch4 学习指南：地址空间

## 学习目标

理解虚拟内存机制如何为每个进程提供独立的地址空间。

## 核心问题清单

### 虚拟内存基础
1. 为什么需要虚拟内存？没有虚拟内存会有什么问题？（想想 Ch3 的不足）
2. Sv39 的"39"是什么意思？虚拟地址空间有多大？
3. 三级页表是如何工作的？VPN[2] → VPN[1] → VPN[0] 分别对什么级别？
4. 一个页面（Page）有多大？为什么选择 4 KiB？

### 内核设计
5. 什么是"恒等映射"（Identity Mapping）？内核为什么使用恒等映射？
6. "异界传送门"（MultislotPortal）解决了什么问题？（提示：切换 satp 后代码地址会失效）
7. satp 寄存器存储了什么？写入 satp 后发生了什么？
8. 为什么 Ch4 的异常类型从 StoreFault 变成了 StorePageFault？

### 系统调用与地址翻译
9. Ch4 的 write 系统调用和 Ch2/Ch3 的有什么区别？为什么需要 `translate()`？
10. sbrk 系统调用是如何工作的？break 指针是什么？

## AI 对话示例

```
你：切换 satp 后为什么代码还能继续执行？

AI：这就是异界传送门（Portal）的作用。传送门页面被同时映射到内核和
所有用户地址空间的相同虚拟地址（VPN::MAX，即虚拟地址空间的最高页）。

切换 satp 的代码位于传送门页面中，由于新旧地址空间在该虚拟地址的
映射指向同一物理页面，所以切换 satp 后 PC 指向的物理地址不变，
代码可以继续执行。

你：如果没有传送门，直接切换 satp 会怎样？

AI：PC 中存的是虚拟地址，切换 satp 后新页表可能没有这个虚拟地址的
映射，CPU 会触发 InstructionPageFault，内核崩溃。
```

## 实验步骤

1. 阅读 `ch4/src/main.rs`（631行，最长的一章）
2. 重点关注 `kernel_space()` 函数和地址翻译逻辑
3. 运行实验，观察内核内存布局和 sbrk 测试结果
4. 对比 Ch3 和 Ch4 的异常处理差异

## 扩展思考

- .data 段为什么占了 ~16.7 MiB？（提示：用户程序 ELF 嵌入在 .data 中）
- 如果两个进程的虚拟地址相同（如都从 0x10000 开始），它们的数据会冲突吗？
- `deallocate` 和 `drop_root` 为什么标记为 `todo!()`？这说明了什么？
