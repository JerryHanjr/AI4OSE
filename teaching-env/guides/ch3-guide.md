# Ch3 学习指南：多道程序与分时多任务

## 学习目标

理解多个程序如何在单个 CPU 上并发执行，以及操作系统如何调度它们。

## 核心问题清单

### 基础问题
1. "并发"和"并行"的区别是什么？Ch3 实现的是哪种？
2. 任务控制块（TCB）需要保存哪些信息？为什么？
3. 协作式调度和抢占式调度各有什么优缺点？

### 调度机制
4. 时钟中断如何触发？`set_timer(time::read64() + 12500)` 中的 12500 代表什么？
5. QEMU virt 平台的时钟频率是多少？一个时间片大约多长？
6. 轮转调度（Round-Robin）是如何实现的？`i = (i + 1) % index_mod` 的含义？

### 中断处理
7. `sie::set_stimer()` 做了什么？如果不设置会怎样？
8. 时钟中断处理中为什么要 `set_timer(u64::MAX)`？
9. yield 系统调用和时钟中断的效果有什么区别？

## AI 对话示例

```
你：时间片大小 12500 cycles 对应多少时间？

AI：QEMU virt 平台的时钟频率是 12.5 MHz（12,500,000 Hz），
所以 12500 cycles = 12500 / 12500000 = 0.001 秒 = 1 毫秒。
每个任务获得 1ms 的执行时间后被抢占。

你：那为什么输出中 AAAA 和 BBBB 交替出现？

AI：因为每个任务执行 1ms 后触发时钟中断，内核切换到下一个就绪任务。
写 10 个 A 需要多次 write 系统调用，可能需要多个时间片才能完成，
所以你看到 A[1/5] 后立即切换到 B[1/2]，然后 C[1/3]。
```

## 实验步骤

1. 阅读 `ch3/src/main.rs`（316行）
2. 重点关注调度循环和时钟中断处理
3. 运行实验，观察 AAAA/BBBB/CCCC 的交替输出模式
4. 思考：如果增大时间片（如 125000 cycles），输出模式会如何变化？

## 扩展思考

- 12 个任务同时驻留内存，内核栈为什么需要 272 KiB 这么大？
- 如果某个任务不断 yield，会不会饿死其他任务？
- Ch3 中多个任务共享物理内存，一个任务能否读写另一个任务的数据？
